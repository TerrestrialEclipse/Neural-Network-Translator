using System;
using System.Collections.Generic;
using NeuralNetwork;
using Layers;
using Tensor;

namespace NeuralNetworkTemplate
{
	class NeuralNetworkTemplate
    {
        static private ActivationType decodeActivationType(int code)
        {
            switch (code)
            {
                case (0):
                    return ActivationType.linear;
                    break;
                case (1):
                    return ActivationType.sigmoid;
                    break;
                case (2):
                    return ActivationType.relu;
                    break;
                case (3):
                    return ActivationType.tanh;
                    break;
                case (4):
                    return ActivationType.softmax;
                    break;
                default:
                    throw new NotImplementedException();
            }
        }

        public static void Main(string[] args)
        {
            int numLayers = ###dimNumberLayers###;
            int[] layerOutputHeight = ###layerOutputHeight###;
            int[] layerOutputWidth = ###layerOutputWidth###;
            int[] layerOutputDepth = ###layerOutputDepth###;
            int[] layerTypes = ###layerTypes###;
            int[] activationTypes = ###activationFunctions###;
            var weights = new Tensor<double>(new double[] ###weights###);
            // int dimWeights = ###dimWeights###;
            int[] indicesWeights = ###indicesWeights###;
            var bias = new Tensor<double>(new double[] ###bias###);
            // int dimBias = ###dimBias###;
            int[] indicesBias = ###indicesBias###;
            int[] useBias = ###useBias###;
            int[] poolHeights = ###poolHeights###;
            int[] poolWidths = ###poolWidths###;
            int[] verticalStride = ###verticalStride###;
            int[] horizontalStride = ###horizontalStride###;
            int[] padding = ###padding###;

            int inputHeight = layerOutputHeight[0];
            int inputWidth = layerOutputWidth[0];
            int inputDepth = layerOutputDepth[0];

            int[] inputShape;
            if (inputWidth == 0)
            {
                 inputShape = new int[] { inputHeight };
            }
            else if (inputDepth == 0)
            {
                inputShape = new int[] { inputHeight, inputWidth };
            }
            else
            {
                inputShape = new int[] { inputHeight, inputWidth, inputDepth };
            }

            var inputLayer = new InputLayer<double>(inputShape);

            var layerList = new List<BaseLayer<double>>();
            layerList.Add(inputLayer);

            BaseLayer<double> prevLayer = inputLayer;
            int poolHeight, poolWidth;
            PaddingType paddingType;

            for (int layer_idx = 1; layer_idx <= numLayers; layer_idx++)
            {
                switch (layerTypes[layer_idx - 1])
                {
                    case (1): // dense layer
                        int weightsIndexUpper;
                        int biasIndexUpper;
                        if (layer_idx == numLayers)
                        {
                            weightsIndexUpper = weights.Shape[0];
                            biasIndexUpper = bias.Shape[0];
                        }
                        else
                        {
                            weightsIndexUpper = indicesWeights[layer_idx];
                            biasIndexUpper = indicesBias[layer_idx];
                        }
                        var denseLayer = new Dense<double>(prevLayer.OutputShape, layerOutputHeight[layer_idx],
                            decodeActivationType(activationTypes[layer_idx - 1]), Convert.ToBoolean(useBias[layer_idx - 1]));

                        int[] weightsShape = { prevLayer.OutputShape[0], layerOutputHeight[layer_idx] };
                        var layerWeights = weights[indicesWeights[layer_idx - 1]..weightsIndexUpper];
                        layerWeights = layerWeights.reshape(weightsShape);

                        int biasShape = layerOutputHeight[layer_idx];
                        var layerBias = bias[indicesBias[layer_idx - 1]..biasIndexUpper];
                        layerBias = layerBias.reshape(biasShape);

                        denseLayer.Weights = layerWeights;
                        denseLayer.Bias = layerBias;

                        layerList.Add(denseLayer);
                        prevLayer = denseLayer;
                        break;
                    case (2): // flatten
                        var flattenLayer = new Flatten<double>(prevLayer.OutputShape);
                        layerList.Add(flattenLayer);
                        prevLayer = flattenLayer;
                        break;
                    case (3): // maxpooling
                        poolHeight = poolHeights[layer_idx - 1];
                        poolWidth = poolWidths[layer_idx - 1];
                        
                        if (padding[layer_idx-1] == 0)
                        {
                            paddingType = PaddingType.valid;
                        }
                        else
                        {
                            paddingType = PaddingType.same_keras;
                        }

                        if (poolWidth == 0)
                        {
                            int stride = verticalStride[layer_idx - 1];
                            // 1D Pooling
                            var maxPoolingLayer = new PoolingLayer1D<double>(prevLayer.OutputShape, PoolingType.max, poolHeight, stride, paddingType);
                            layerList.Add(maxPoolingLayer);
                            prevLayer = maxPoolingLayer;
                        }
                        else
                        {
                            int[] stride = { verticalStride[layer_idx - 1], horizontalStride[layer_idx - 1] };
                            int[] poolSize = { poolHeight, poolWidth };
                            // 2D Pooling
                            var maxPoolingLayer = new PoolingLayer2D<double>(prevLayer.OutputShape, PoolingType.max, poolSize, stride, paddingType);
                            layerList.Add(maxPoolingLayer);
                            prevLayer = maxPoolingLayer;
                        }
                        
                        break;
                    case (4): // avgpooling
                        poolHeight = poolHeights[layer_idx - 1];
                        poolWidth = poolWidths[layer_idx - 1];

                        if (padding[layer_idx - 1] == 0)
                        {
                            paddingType = PaddingType.valid;
                        }
                        else
                        {
                            paddingType = PaddingType.same_keras;
                        }

                        if (poolWidth == 0)
                        {
                            int stride = verticalStride[layer_idx - 1];
                            // 1D Pooling
                            var avgPoolinglayer = new PoolingLayer1D<double>(prevLayer.OutputShape, PoolingType.average, poolHeight, stride, paddingType);
                            layerList.Add(avgPoolinglayer);
                            prevLayer = avgPoolinglayer;
                        }
                        else
                        {
                            int[] stride = { verticalStride[layer_idx - 1], horizontalStride[layer_idx - 1] };
                            int[] poolSize = { poolHeight, poolWidth };
                            // 2D Pooling
                            var avgPoolinglayer = new PoolingLayer2D<double>(prevLayer.OutputShape, PoolingType.average, poolSize, stride, paddingType);
                            layerList.Add(avgPoolinglayer);
                            prevLayer = avgPoolinglayer;
                        }
                        
                        break;
                    default:
                        throw new NotImplementedException();
                }
            }
            var net = new NeuralNetwork<double>(layerList);

            int batchSize = 1;
            var shape = new List<int>();
            shape.Add(batchSize);
            shape.AddRange(inputShape);
            var X = Tensor<double>.randNormal(0, 1, shape.ToArray());
            Console.WriteLine(X);

            var y = net.predict(X);
            Console.WriteLine(y);

        }
    }
}